
What is authentication and authorization?
Authentication and authorization are used in security, particularly when it comes to getting access to a system. Yet, there is a significant distinction between gaining entry into a house (authentication) and what you can do while inside (authorization).


Authentication
-- Authentication is the process of verifying a user’s identification through the acquisition of credentials and using those credentials to confirm the user’s identity. 
--The authorization process begins if the credentials are legitimate. The authorization process always follows the authentication procedure.

Authorization
--Authorization is the process of allowing authenticated users access to resources by determining whether they have system access permissions.
--By giving or denying specific licenses to an authenticated user, authorization enables you to control access privileges.

What is JWT?
--JSON Web Tokens (JWT) are an RFC 7519 open industry standard for representing claims between two parties.
--JWT specifies a compact and self-contained method for communicating information as a JSON object between two parties

Working of JWT
--Once successful they would receive a token that looks like this:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ.2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54
Imp-note below
--This is a JWT, and consists of three parts (separated by .):
	1. The first part is the header (eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9). The header specifies information like the algorithm used to generate the signature (the third part). This part is pretty standard and is the same for any JWT using the same algorithm.
	2. The second part is the payload (eyJ1c2VybmFtZSI6InVzZXIxIiwiZXhwIjoxNTQ3OTc0MDgyfQ), which contains application specific information (in our case, this is the username), along with information about the expiry and validity of the token.
	3. The third part is the signature (2Ye5_w1z3zpD4dSGdRp3s98ZipCNQqmsHRB9vioOx54). It is generated by combining and hashing the first two parts along with a secret key.

Note:Now the interesting thing is that the header and payload are not encrypted. They are just base64 encoded. This means that anyone can view their contents by decoding them.

So how it is secure ???

-- if the header and signature of a JWT can be read and written to by anyone, what actually makes a JWT secure? The answer lies in how the last part (the signature) is generated.

--Making the header and payload are pretty straightforward: The header is more or less fixed, and the payload JSON object is formed by setting the user ID and the expiry time in unix milliseconds.

--The application issuing the token will also have a key, which is a secret value, and known only to the application itself. The base64 representations of the header and payload are then combined with the secret key and then passed through a hashing algorithm (in this case its HS256, as mentioned in the header)



Verifying a JWT
--In order to verify an incoming JWT, a signature is once again generated using the header and payload from the incoming JWT, and the secret key. If the signature matches the one on the JWT, then the JWT is considered valid.
--Now let’s pretend that you’re a hacker trying to issue a fake token. You can easily generate the header and payload, but without knowing the key, there is no way to generate a valid signature. If you try to tamper with the existing payload of a valid JWT, the signatures will no longer match.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Install Package

--> npm install jsonwebtoken

Import

-->const jwt=require("jsonwebtoken")

Creating a token

Syntax:
jwt.sign(payload, secretOrPrivateKey, [options, callback])

options:
	• algorithm (default: HS256)
	• expiresIn: expressed in seconds or a string describing a time span zeit/ms.
Eg: 60, "2 days", "10h", "7d". A numeric value is interpreted as a seconds count. If you use a string be sure you provide the time units (days, hours, etc), otherwise milliseconds unit is used by default ("120" is equal to "120ms").
	• Etc…

To sign a token, you will need to have 3 pieces of information:

	• The token secret
	• The piece of data to hash in the token
	• The token expire time

Example:
  const token= jwt.sign(username, process.env.TOKEN_SECRET, { expiresIn: '1800s' });
Our ex: 
//creating a token
    const token= jwt.sign({userId:user._id},"Guv!@123",{expiresIn:"1d"})


Handling  authentication routes

Now for every router other than login&registration.,we need to send tokens from front-end and
Validate those tokens in backend,

Using jwt.verify() the token 
--use try and catch to move to next middleware
--if successful, store the user in req and use next()
--if error , send error response

In app.js
try{
    const user=jwt.verify(token,"Guv!@123");
    req.user=user;
    console.log(req.user)
    next()
    }
    catch(err)
    {
        res.status(401).send(err)
    }

Handling Authorization

Now you verify the user for each request using the req.user

For example:1
After logging ,display posts for the user who logged in 
async findPosts(req,res,next){
        //logic in db to retrieve data
        try{
          //using .toArray() method to get response as Array of objects for find()
         //displaying posts for the user who logged in---Authorization
        const data= await mongo.posts.find({userId:req.user.userId}).toArray()
        // console.log(data)
     res.send(data)
        }
        catch(err)
        {
          console.log("Error in Get data",err)
        }
    },

Example2: for creating post, create userId and send the id from the req.user.userId

async insertPosts(req,res,next){
        //accessing req-body will returns undefined ,in-order to access req.body we have to use a middleware express.json()
        console.log( req.body)

        try{
        //logic in db to insert document
        const data=await mongo.posts.insertOne({...req.body,userId:req.user.userId})
        console.log(data)

        res.status(201).send({...req.body,_id:data.insertedId})
        }
        
        catch(err)
        {
          console.log("Error in Post data",err)
        }
      },

Example 3:
Allowing the user to delete only if he is the owner of the post

//delete method
    async deletePosts(req,res,next){
        console.log(req.params.id)
        //logic in  db to delete data 
        try{

          //Authorization-- verfiy that user to be deleted is the owner of the post
          const selectPosts=await mongo.posts.findOne({_id:ObjectId(req.params.id),userId:req.user.userId})
          console.log(selectPosts)
          if(!selectPosts)
          { console.log("in")
            return res.status(401).send("you are not authorized to delete this post")
           }
         await mongo.posts.deleteOne({_id:ObjectId(req.params.id)})
        res.end()
        }
        catch(err)
        {
          console.log("Error in Delete data",err) 
        }
    }








